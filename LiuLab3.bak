;; The first three lines of this file were inserted by DrRacket. They record metadata
;; about the language level of this file in a form that our tools can easily process.
#reader(lib "htdp-intermediate-lambda-reader.ss" "lang")((modname LiuLab3) (read-case-sensitive #t) (teachpacks ()) (htdp-settings #(#t constructor repeating-decimal #f #t none #f () #f)))
;Teaching Language does not contain function string-contains? so here's a function that does it
(define string-contains
  (lambda (str char)
    (cond [(= (string-length str) 0) #f]
          [(char=? (string-ref str 0) char) #t]
          (else (string-contains (substring str 1) char))
          )
    )
  )

(define char-to-int
  (lambda (c)
  (- (char->integer c) (char->integer #\0))
  )
  )

(define (int-to-char n)
  ;(if (and (integer? n) (>= n 0) (< n 16))
      (if (< n 10)
          (integer->char(+ n (char->integer #\0)))
          (integer->char(+ (- n 10) (char->integer #\A)))) 
   ;   (error "Input must be a non-negative integer less than 16")))
  )
  
;Rep->number
(define (rep->number base s)
  (cond [(string-contains s #\-) (* -1 (+ (Adot (substring s 1) (string-length base)) (Bdot (substring s 1) (string-length base))))]
  [(string-contains s #\+) (+ (Adot (substring s 1) (string-length base)) (Bdot (substring s 1) (string-length base)))]
  [(= (string-length base) 10) s]
  )
  )

;Transform the string to base if the base is in letter
(define (Assign base s k poss posb)
  (if (= posb (string-length base)) 
      s 
      (if (string-contains s (string-ref base posb))
          (if (char=? (string-ref s poss) (string-ref base posb))
               (string-append (substring s 0 poss)
                              (Assign base (string-append (string (int-to-char k)) (substring s (+ poss 1))) k (+ poss 1) posb))
              (Assign base s k (+ poss 1) posb))
          (Assign base s (+ k 1) 0 (+ posb 1))))
  )

(define (Transform base s k)
  (let [(base (string->list base))
        (s (string->list s))]
    (cond [(char=? (first base) (first s)) (Transform base (cons k (cdr s)) k)]

          
          )
    )
  )

  

;AfterDot
(define Adot
  (lambda (s base)
    (let ((k (string-length s)))
      (if (string-contains s #\.)
          (Adot (substring s 1) base)
      (if (<= k 0)
          0
          (+ (/ (char-to-int (string-ref s (- k 1))) (expt base k)) (Adot (substring s 0 (- k 1)) base))
          )
      )
    )
  )
  )

;BeforeDot
(define Bdot
  (lambda (s base)
    (let ((k (- (string-length s) 1)))
      (if (string-contains s #\.)
          (Bdot (substring s 0 k) base)
          (if (< k 0)
              0
              (+ (* (expt base k) (char-to-int (string-ref s 0))) (Bdot (substring s 1) base))
          ))
      )
    )
  )



;Debug 
(define (conv s base)
  (if (integer? base)
      (string->number s base)
      (string->number s (string-length base))
      )
  )
  



